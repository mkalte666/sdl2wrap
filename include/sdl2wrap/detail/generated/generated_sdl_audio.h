/*
  SDL2 C++ Wrapper
  Copyright (C) 2020 Malte Kie√üling <mkalte@mkalte.me>

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.
*/
/**
 * Everything in this file is generated. Please use scripts/generate.py to update it! 
 */
#ifndef sdl2wrap_generated_SDL_audio
#define sdl2wrap_generated_SDL_audio

#include "SDL_audio.h"

namespace sdl2wrap {

/**
 * \brief Scoped version of SDL_AudioStatus
 * 
 * Generated From SDL_audio.h:400
 * \sa SDL_AudioStatus
 */
enum class AudioStatus : Uint32 {
    Stopped = SDL_AUDIO_STOPPED, ///< NOLINT \wrapImpl SDL_AUDIO_STOPPED AudioStatus::Stopped autogenerated
    Playing = SDL_AUDIO_PLAYING, ///< NOLINT \wrapImpl SDL_AUDIO_PLAYING AudioStatus::Playing autogenerated
    Paused = SDL_AUDIO_PAUSED, ///< NOLINT \wrapImpl SDL_AUDIO_PAUSED AudioStatus::Paused autogenerated
};
inline bool operator==(SDL_AudioStatus a, AudioStatus b) noexcept
{
    return a == static_cast<SDL_AudioStatus>(b);
}
inline bool operator==(AudioStatus a, SDL_AudioStatus b) noexcept
{
    return a == static_cast<AudioStatus>(b);
}
inline AudioStatus operator|(AudioStatus a, AudioStatus b) noexcept
{
    return static_cast<AudioStatus>(static_cast<Uint32>(a) | static_cast<Uint32>(b));
}

/**
 * \brief scoped enum for AUDIO_* defines
 * 
 * Generated from SDL_audio.h
 * \sa AUDIO_*
 */
enum class AudioFormat : Uint32 {
    U8 = AUDIO_U8, ///< NOLINT \wrapImpl AUDIO_U8 AudioFormat::U8 autogenerated
    S8 = AUDIO_S8, ///< NOLINT \wrapImpl AUDIO_S8 AudioFormat::S8 autogenerated
    U16lsb = AUDIO_U16LSB, ///< NOLINT \wrapImpl AUDIO_U16LSB AudioFormat::U16lsb autogenerated
    S16lsb = AUDIO_S16LSB, ///< NOLINT \wrapImpl AUDIO_S16LSB AudioFormat::S16lsb autogenerated
    U16msb = AUDIO_U16MSB, ///< NOLINT \wrapImpl AUDIO_U16MSB AudioFormat::U16msb autogenerated
    S16msb = AUDIO_S16MSB, ///< NOLINT \wrapImpl AUDIO_S16MSB AudioFormat::S16msb autogenerated
    U16 = AUDIO_U16, ///< NOLINT \wrapImpl AUDIO_U16 AudioFormat::U16 autogenerated
    S16 = AUDIO_S16, ///< NOLINT \wrapImpl AUDIO_S16 AudioFormat::S16 autogenerated
    S32lsb = AUDIO_S32LSB, ///< NOLINT \wrapImpl AUDIO_S32LSB AudioFormat::S32lsb autogenerated
    S32msb = AUDIO_S32MSB, ///< NOLINT \wrapImpl AUDIO_S32MSB AudioFormat::S32msb autogenerated
    S32 = AUDIO_S32, ///< NOLINT \wrapImpl AUDIO_S32 AudioFormat::S32 autogenerated
    F32lsb = AUDIO_F32LSB, ///< NOLINT \wrapImpl AUDIO_F32LSB AudioFormat::F32lsb autogenerated
    F32msb = AUDIO_F32MSB, ///< NOLINT \wrapImpl AUDIO_F32MSB AudioFormat::F32msb autogenerated
    F32 = AUDIO_F32, ///< NOLINT \wrapImpl AUDIO_F32 AudioFormat::F32 autogenerated
    U16sys = AUDIO_U16SYS, ///< NOLINT \wrapImpl AUDIO_U16SYS AudioFormat::U16sys autogenerated
    S16sys = AUDIO_S16SYS, ///< NOLINT \wrapImpl AUDIO_S16SYS AudioFormat::S16sys autogenerated
    S32sys = AUDIO_S32SYS, ///< NOLINT \wrapImpl AUDIO_S32SYS AudioFormat::S32sys autogenerated
    F32sys = AUDIO_F32SYS, ///< NOLINT \wrapImpl AUDIO_F32SYS AudioFormat::F32sys autogenerated
};
inline AudioFormat operator|(AudioFormat a, AudioFormat b) noexcept
{
    return static_cast<AudioFormat>(static_cast<Uint32>(a) | static_cast<Uint32>(b));
}

/**
 * \brief scoped enum for SDL_AUDIO_ALLOW_* defines
 * 
 * Generated from SDL_audio.h
 * \sa SDL_AUDIO_ALLOW_*
 */
enum class AudioAllow : Uint32 {
    FrequencyChange = SDL_AUDIO_ALLOW_FREQUENCY_CHANGE, ///< NOLINT \wrapImpl SDL_AUDIO_ALLOW_FREQUENCY_CHANGE AudioAllow::FrequencyChange autogenerated
    FormatChange = SDL_AUDIO_ALLOW_FORMAT_CHANGE, ///< NOLINT \wrapImpl SDL_AUDIO_ALLOW_FORMAT_CHANGE AudioAllow::FormatChange autogenerated
    ChannelsChange = SDL_AUDIO_ALLOW_CHANNELS_CHANGE, ///< NOLINT \wrapImpl SDL_AUDIO_ALLOW_CHANNELS_CHANGE AudioAllow::ChannelsChange autogenerated
    SamplesChange = SDL_AUDIO_ALLOW_SAMPLES_CHANGE, ///< NOLINT \wrapImpl SDL_AUDIO_ALLOW_SAMPLES_CHANGE AudioAllow::SamplesChange autogenerated
    AnyChange = SDL_AUDIO_ALLOW_ANY_CHANGE, ///< NOLINT \wrapImpl SDL_AUDIO_ALLOW_ANY_CHANGE AudioAllow::AnyChange autogenerated
};
inline AudioAllow operator|(AudioAllow a, AudioAllow b) noexcept
{
    return static_cast<AudioAllow>(static_cast<Uint32>(a) | static_cast<Uint32>(b));
}

} // namespace sdl2wrap

#endif // sdl2wrap_generated_*
